// SPDX-License-Identifier: MIT
pragma solidity ^0.8.21;

import "@openzeppelin/contracts/utils/Counters.sol";

error Voting__InvalidChoiceIndex(uint256 choiceIndex);
error Voting__InvalidState();
error Voting__InvalidVoter();
error Voting__AlreadyVoted();
error Voting__NotOwner();
error Voting__DisabledForOwner();
error Voting__UserHasNotVoted(address voterAddress);
error Voting__UserNotAllowedToVote(address voterAddress);

/// @title Voting Smart Contract for Cloak Voting App
/// @author Olivier Kobialka @OlivierKobialka 2024
contract Voting {
    using Counters for Counters.Counter;
    Counters.Counter private totalPolls;
    Counters.Counter private totalVoters;

    struct SPoll {
        uint256 id; // totalPolls.current()
        address creator; // msg.sender
        string title;
        string description;
        string image;
        string category;
        string[2] choices;
        uint256 endTime;
        uint256 timestamp; // block.timestamp
        bool isPrivate;
        address[] allowedVoters;
        SVoter[] voters;
    }

    struct SVoter {
        address voterAddress; // msg.sender
        uint256 choiceIndex;
    }

    mapping(uint256 => SPoll) public polls;
    mapping(uint256 => mapping(address => bool)) public isOwner;
    mapping(address => bool) public hasVoted;

    event PollCreated(
        uint256 indexed id,
        address creator,
        string title,
        string description,
        string image,
        string category,
        string[2] choices,
        uint256 endTime,
        uint256 timestamp,
        bool isPrivate,
        address[] allowedVoters
    );

    event PollVoted(uint256 indexed id, SVoter voter);

    function createPoll(
        string memory title,
        string memory description,
        string memory image,
        string memory category,
        string[2] memory choices,
        uint256 endTime,
        bool isPrivate,
        address[] memory allowedVoters
    ) public {
        require(choices.length == 2, "Voting: Choices must be exactly 2");

        totalPolls.increment();
        SPoll storage poll = polls[totalPolls.current()];
        poll.id = totalPolls.current();
        poll.creator = msg.sender;
        poll.title = title;
        poll.description = description;
        poll.image = image;
        poll.category = category;
        poll.choices = choices;
        poll.endTime = endTime;
        poll.timestamp = block.timestamp;
        poll.isPrivate = isPrivate;
        poll.allowedVoters = allowedVoters;

        emit PollCreated(
            poll.id,
            poll.creator,
            poll.title,
            poll.description,
            poll.image,
            poll.category,
            poll.choices,
            poll.endTime,
            poll.timestamp,
            poll.isPrivate,
            poll.allowedVoters
        );
    }

    function vote(uint256 pollId, uint256 choiceIndex) public {
        SPoll storage poll = polls[pollId];
        require(poll.id != 0, "Voting: Poll does not exist");
        require(block.timestamp < poll.endTime, "Voting: Poll has ended");

        if (poll.isPrivate) {
            require(
                isOwner[pollId][msg.sender],
                "Voting: User not allowed to vote"
            );
            require(poll.allowedVoters.length > 0, "Voting: No allowed voters");
            require(
                poll.allowedVoters[totalVoters.current()] == msg.sender,
                "Voting: User not allowed to vote"
            );
        }

        SVoter storage voter = poll.voters[totalVoters.current()];
        voter.voterAddress = msg.sender;
        voter.choiceIndex = choiceIndex;

        emit PollVoted(poll.id, voter);
    }

    function getOwner(uint256 pollId) public view returns (address) {
        return polls[pollId].creator;
    }

    function getAllVoteCount(
        uint256 pollId
    ) public view returns (uint256[2] memory) {
        SPoll storage poll = polls[pollId];
        require(poll.id != 0, "Voting: Poll does not exist");

        uint256[2] memory voteCount;
        for (uint256 i = 0; i < poll.voters.length; i++) {
            voteCount[poll.voters[i].choiceIndex]++;
        }

        return voteCount;
    }

    function getChoiceCount(
        uint256 pollId,
        uint256 choiceIndex
    ) public view returns (uint256) {
        SPoll storage poll = polls[pollId];
        require(poll.id != 0, "Voting: Poll does not exist");
        require(
            choiceIndex < poll.choices.length,
            "Voting: Invalid choice index"
        );

        uint256 voteCount = 0;
        for (uint256 i = 0; i < poll.voters.length; i++) {
            if (poll.voters[i].choiceIndex == choiceIndex) {
                voteCount++;
            }
        }

        return voteCount;
    }

    function getChoiceVotersAddresses(
        uint256 pollId,
        uint256 choiceIndex
    ) public view returns (address[] memory) {
        SPoll storage poll = polls[pollId];
        require(poll.id != 0, "Voting: Poll does not exist");
        require(
            choiceIndex < poll.choices.length,
            "Voting: Invalid choice index"
        );

        address[] memory votersAddresses = new address[](poll.voters.length);
        uint256 votersAddressesIndex = 0;
        for (uint256 i = 0; i < poll.voters.length; i++) {
            if (poll.voters[i].choiceIndex == choiceIndex) {
                votersAddresses[votersAddressesIndex] = poll.voters[i]
                    .voterAddress;
                votersAddressesIndex++;
            }
        }

        return votersAddresses;
    }
}
